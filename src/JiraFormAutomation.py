import Ticket
import time
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as ec

LANDING = "https://service.rochester.edu/servicedesk/customer/portal/101/create/358?q=lending&q_time=1693601714516"
CHROME_PATH = r'--user-data-dir=C:/Users/rettnerhelpdesk/AppData/Local/Google/Chrome'
CHROME_PROFILE = '--profile-directory=Profile 4'
SIGNATURE = "This ticket was automatically generated by the Rettner 201 Helpdesk. If you have received this in error, you may contact the desk at rettnerhelpdesk@ur.rochester.edu"


class JiraFormAutomation:
    def __init__(self, ticket: Ticket, root, progress_bar, progress):
        self.NUM_UPDATES = 11

        self.progress_int = 0
        self.progress = progress
        self.root = root
        self.progress_bar = progress_bar
        self.customer = ticket.name
        self.action = ticket.action
        self.items = ticket.item
        self.options = webdriver.ChromeOptions()
        self.options.add_argument(CHROME_PATH)
        self.options.add_argument(CHROME_PROFILE)
        #self.options.add_argument('--headless')
        self.browser = webdriver.Chrome(options=self.options)

    def open_landing_page(self):
        self.browser.get(LANDING)
        self.update_progress()

        # Wait for page load and check if login is required
        WebDriverWait(self.browser, 30).until(ec.url_contains("service.rochester.edu"))
        if "service.rochester.edu" not in self.browser.current_url:
            return "Could not reach landing page, try logging in."
            # Login.LoginForm(tk.Tk(), self.browser)
            # self.open_landing_page()
        self.update_progress()

    def fill_form(self):
        # Wait until the customer input is present
        customer_element = WebDriverWait(self.browser, 30).until(
            ec.presence_of_element_located((By.XPATH, '//*[@id="react-select-2-input"]'))
        )
        self.update_progress()
        source_element = self.browser.find_elements(By.XPATH,
                                                    '//*[@id="react-select-customfield_10808-instance-input"]')
        summary_element = self.browser.find_elements(By.XPATH, '//*[@id="summary"]')
        description_element = self.browser.find_elements(By.XPATH, '//*[@id="ak-editor-textarea"]')

        customer_element.send_keys(self.customer[1], ", ", self.customer[0])
        time.sleep(2)
        customer_element.send_keys(Keys.RETURN)
        self.update_progress()

        WebDriverWait(self.browser, 30).until(
            ec.element_to_be_clickable((By.XPATH, '//*[@id="react-select-customfield_10808-instance-input"]')))
        source_element[0].send_keys('Walk In')
        source_element[0].send_keys(Keys.RETURN)
        description_element[0].send_keys(SIGNATURE)
        summary_element[0].send_keys(self.action, ": ", self.items)
        summary_element[0].send_keys(Keys.RETURN)
        
        print("Form filled")
        self.update_progress()

        # Wait for form submission and completion
        WebDriverWait(self.browser, 30).until(ec.invisibility_of_element_located((By.XPATH, '//*[@id="summary"]')))

    def resolve_ticket(self):
        print('Resolving')
        resolve = WebDriverWait(self.browser, 30).until(
            ec.element_to_be_clickable((By.XPATH, '//*[@id="com.atlassian.servicedesk:workflow-transition-761"]'))
        )
        resolve.click()
        WebDriverWait(self.browser, 30).until(ec.element_to_be_clickable((By.XPATH, '/html/body/section/form')))
        self.browser.find_elements(By.XPATH, '/html/body/section/form')[0].submit()
        print("Ticket resolved")
        self.update_progress()

    def assign_ticket(self):
        print('Opening ticket information')
        time.sleep(2)
        # TODO: add in error handling in case the menu is already toggled open
        self.browser.find_elements(By.XPATH, '//*[@id="content"]/div/header/div/div/div[2]/div[2]/div/ol/li[3]/a')[
            0].click()
        self.update_progress()
        
        # try to click the "assign to me" button
        try:
            print("attempting to find \"assign to me\"")
            assign_button = WebDriverWait(self.browser, 30).until(ec.element_to_be_clickable((By.XPATH, '//*[@id="assign-to-me"]')))
        except:
            print("could not find \"assign to me\" button, expanding the \"people\" bar.")
            expand_people_dropdown = WebDriverWait(self.browser, 10).until(
                ec.element_to_be_clickable((By.XPATH, '//*[@id="peoplemodule-label"]/button/span')))
            expand_people_dropdown.click()
            print("\"people\" bar expanded")
        finally:
            print("clicking \"assign to me\"")
            assign_button = WebDriverWait(self.browser, 30).until(ec.element_to_be_clickable((By.XPATH, '//*[@id="assign-to-me"]')))
        
        print("clicked assign button")
        self.update_progress()
        print('Assigned to me')

    def close_ticket(self):
        print('Closing ticket')
        time.sleep(20)
        transition_bar = WebDriverWait(self.browser, 30).until(
            ec.element_to_be_clickable((By.XPATH, '//*[@id="opsbar-transitions_more"]/span')))
        transition_bar.click()
        self.update_progress()
        close_button = WebDriverWait(self.browser, 30).until(
            ec.element_to_be_clickable((By.XPATH, '//*[@id="action_id_941"]/a/div/div[1]'))
        )
        close_button.click()
        time.sleep(10)
        self.update_progress()
        print('Ticket closed successfully.')

    def run(self):
        try:
            self.open_landing_page()
            self.fill_form()
            self.resolve_ticket()
            self.assign_ticket()
            self.close_ticket()
            self.browser.quit()
            return "Successfully submitted ticket."
        except:
            print("ticket submission failed")
            print(self.browser.current_url)
            failure_message = "Ticket submission failure: " + self.browser.current_url
            return failure_message

    def update_progress(self):
        self.progress_int += 10
        self.progress.set(self.progress_int)
        self.progress_bar.update_idletasks()
        self.root.update_idletasks()
